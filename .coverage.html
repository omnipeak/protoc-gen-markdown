
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>converter: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/omnipeak/protoc-gen-markdown/internal/converter/converter.go (1.9%)</option>
				
				<option value="file1">github.com/omnipeak/protoc-gen-markdown/internal/converter/enum.go (56.0%)</option>
				
				<option value="file2">github.com/omnipeak/protoc-gen-markdown/internal/converter/enum_data.go (90.0%)</option>
				
				<option value="file3">github.com/omnipeak/protoc-gen-markdown/internal/converter/message.go (10.8%)</option>
				
				<option value="file4">github.com/omnipeak/protoc-gen-markdown/internal/converter/message_data.go (90.0%)</option>
				
				<option value="file5">github.com/omnipeak/protoc-gen-markdown/internal/converter/service.go (61.5%)</option>
				
				<option value="file6">github.com/omnipeak/protoc-gen-markdown/internal/converter/service_data.go (94.1%)</option>
				
				<option value="file7">github.com/omnipeak/protoc-gen-markdown/internal/utils/strings.go (100.0%)</option>
				
				<option value="file8">github.com/omnipeak/protoc-gen-markdown/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package converter

import (
        "flag"
        "fmt"
        "log"
        "path"
        "strings"

        "golang.org/x/text/cases"
        "golang.org/x/text/language"
        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/reflect/protoreflect"
        "google.golang.org/protobuf/reflect/protoregistry"
        "google.golang.org/protobuf/types/dynamicpb"
        "google.golang.org/protobuf/types/pluginpb"
)

type converter struct {
        outputMermaidDiagrams bool

        extTypes *protoregistry.Types
        packages map[string]*packageData
}

func New() *converter <span class="cov8" title="1">{
        return &amp;converter{
                extTypes: new(protoregistry.Types),
                packages: map[string]*packageData{},
        }
}</span>

func Run() <span class="cov0" title="0">{
        c := New()

        flags := flag.FlagSet{
                Usage: func() </span><span class="cov0" title="0">{
                        log.Fatal(
                                "Usage:\n" +
                                        "  protoc --markdown_out=mermaid=true:./path/to/output/dir/ foo.proto\n" +
                                        "  protoc --markdown_out=mermaid=false:./path/to/output/dir/ foo.proto\n\n" +
                                        "markdown_out params:\n" +
                                        "  mermaid: true / false\n",
                        )
                }</span>,
        }

        <span class="cov0" title="0">flags.BoolVar(&amp;c.outputMermaidDiagrams, "mermaid", false, "Generate mermaid diagrams")

        protogen.Options{
                ParamFunc: flags.Set,
        }.Run(c.generate)</span>
}

func (c *converter) generate(plugin *protogen.Plugin) error <span class="cov0" title="0">{
        plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

        for _, file := range plugin.Files </span><span class="cov0" title="0">{
                if err := registerAllExtensions(c.extTypes, file.Desc); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if file.Generate </span><span class="cov0" title="0">{
                        if err := c.processFile(plugin, file); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">f := plugin.NewGeneratedFile("index.md", "")
        f.P("# Index")
        f.P()

        for i, _ := range c.packages </span><span class="cov0" title="0">{
                f.P(fmt.Sprintf("- %s", i))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *converter) addFile(file *protogen.File) <span class="cov0" title="0">{
        pkgName := string(file.Desc.Package())
        if _, ok := c.packages[pkgName]; !ok </span><span class="cov0" title="0">{
                c.packages[pkgName] = &amp;packageData{
                        enums:      map[string]*protogen.Enum{},
                        extensions: map[string]*protogen.Extension{},
                        files:      map[string]*protogen.File{},
                        messages:   map[string]*protogen.Message{},
                        services:   map[string]*protogen.Service{},
                }
        }</span>

        <span class="cov0" title="0">c.packages[pkgName].files[file.Desc.Path()] = file

        for _, enm := range file.Enums </span><span class="cov0" title="0">{
                c.packages[pkgName].enums[string(enm.Desc.Name())] = enm
        }</span>

        <span class="cov0" title="0">for _, ext := range file.Extensions </span><span class="cov0" title="0">{
                c.packages[pkgName].extensions[string(ext.Desc.Name())] = ext
        }</span>

        <span class="cov0" title="0">for _, msg := range file.Messages </span><span class="cov0" title="0">{
                c.packages[pkgName].messages[string(msg.Desc.Name())] = msg
        }</span>

        <span class="cov0" title="0">for _, svc := range file.Services </span><span class="cov0" title="0">{
                c.packages[pkgName].services[string(svc.Desc.Name())] = svc
        }</span>
}

func (c *converter) processFile(plugin *protogen.Plugin, file *protogen.File) error <span class="cov0" title="0">{
        c.addFile(file)

        g := plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+".md", file.GoImportPath)

        fileName := cases.Title(language.Und, cases.NoLower).String(
                strings.ReplaceAll(
                        strings.Replace(path.Base(file.Desc.Path()), ".proto", "", 1),
                        "_",
                        " ",
                ),
        )

        g.P("# ", fileName)
        g.P()

        for _, service := range file.Services </span><span class="cov0" title="0">{
                if err := c.processService(g, service); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">for _, enum := range file.Enums </span><span class="cov0" title="0">{
                if err := c.processEnum(g, enum); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">for _, message := range file.Messages </span><span class="cov0" title="0">{
                if err := c.processMessage(g, message); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// func (c *converter) processField(g *protogen.GeneratedFile, field *protogen.Field) error {
//         g.P("### ", field.Desc.Name())
//         g.P()

//         return nil
// }

// Recursively register all extensions into the provided protoregistry.Types,
// starting with the protoreflect.FileDescriptor and recursing into its MessageDescriptors,
// their nested MessageDescriptors, and so on.
//
// This leverages the fact that both protoreflect.FileDescriptor and protoreflect.MessageDescriptor
// have identical Messages() and Extensions() functions in order to recurse through a single function
func registerAllExtensions(extTypes *protoregistry.Types, descriptions interface {
        Messages() protoreflect.MessageDescriptors
        Extensions() protoreflect.ExtensionDescriptors
}) error <span class="cov0" title="0">{
        mds := descriptions.Messages()
        for i := 0; i &lt; mds.Len(); i++ </span><span class="cov0" title="0">{
                registerAllExtensions(extTypes, mds.Get(i))
        }</span>
        <span class="cov0" title="0">xds := descriptions.Extensions()
        for i := 0; i &lt; xds.Len(); i++ </span><span class="cov0" title="0">{
                if err := extTypes.RegisterExtension(dynamicpb.NewExtensionType(xds.Get(i))); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package converter

import (
        "fmt"

        "github.com/omnipeak/protoc-gen-markdown/internal/utils"
        "google.golang.org/protobuf/compiler/protogen"
)

func (c *converter) processEnum(g *protogen.GeneratedFile, enum *protogen.Enum) error <span class="cov0" title="0">{
        var err error

        data := &amp;enumData{
                enum:     enum,
                enumName: string(enum.Desc.Name()),
                description: utils.FlattenComment(
                        enum.Comments.Leading.String() + "\n\n" + enum.Comments.Trailing.String(),
                ),
                values:      map[string]*enumValue{},
                valuesOrder: []string{},
        }

        for _, f := range enum.Values </span><span class="cov0" title="0">{
                value := &amp;enumValue{
                        valueName: string(f.Desc.Name()),
                        description: utils.FlattenComment(
                                f.Comments.Leading.String() + " " + f.Comments.Trailing.String(),
                        ),
                }

                data.values[value.valueName] = value
                data.valuesOrder = append(data.valuesOrder, value.valueName)
        }</span>

        <span class="cov0" title="0">err = c.writeEnumFieldsTable(g, data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *converter) writeEnumFieldsTable(g *protogen.GeneratedFile, data *enumData) error <span class="cov8" title="1">{
        g.P("## ", data.enumName)
        g.P()

        if data.description != "" </span><span class="cov8" title="1">{
                g.P(data.description)
                g.P()
        }</span>

        <span class="cov8" title="1">tableData, err := data.GetTableData()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tpl := "| %s | %s |"

        g.P(fmt.Sprintf(
                tpl,
                utils.PadRight("Value", " ", tableData.colLengths[0]),
                utils.PadRight("Description", " ", tableData.colLengths[1]),
        ))

        g.P(fmt.Sprintf(
                tpl,
                utils.PadRight("", "-", tableData.colLengths[0]),
                utils.PadRight("", "-", tableData.colLengths[1]),
        ))

        for _, row := range tableData.rows </span><span class="cov8" title="1">{
                g.P(fmt.Sprintf(
                        tpl,
                        utils.PadRight(row.valueName, " ", tableData.colLengths[0]),
                        utils.PadRight(row.description, " ", tableData.colLengths[1]),
                ))
        }</span>

        <span class="cov8" title="1">g.P()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package converter

import (
        "fmt"

        "github.com/omnipeak/protoc-gen-markdown/internal/utils"
        "google.golang.org/protobuf/compiler/protogen"
)

type enumData struct {
        enum        *protogen.Enum
        enumName    string
        description string
        values      map[string]*enumValue
        valuesOrder []string
}

func (data *enumData) GetTableData() (*enumTableData, error) <span class="cov8" title="1">{
        tableData := &amp;enumTableData{
                colLengths: []int{0, 0},
                rows:       []*enumTableFieldRow{},
        }

        for _, valueKey := range data.valuesOrder </span><span class="cov8" title="1">{
                value, ok := data.values[valueKey]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("value %s not found", valueKey)
                }</span>

                <span class="cov8" title="1">row := &amp;enumTableFieldRow{
                        valueName:   fmt.Sprintf("`%s`", valueKey),
                        description: value.description,
                }

                tableData.rows = append(tableData.rows, row)

                utils.StringGTLengthHelper(&amp;tableData.colLengths[0], row.valueName)
                utils.StringGTLengthHelper(&amp;tableData.colLengths[1], row.description)</span>
        }

        <span class="cov8" title="1">return tableData, nil</span>
}

type enumValue struct {
        valueName   string
        description string
}

type enumTableData struct {
        colLengths []int
        rows       []*enumTableFieldRow
}

type enumTableFieldRow struct {
        valueName   string
        description string
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package converter

import (
        "fmt"
        "strings"

        "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/reflect/protoreflect"

        "github.com/omnipeak/protoc-gen-markdown/internal/utils"
)

func (c *converter) processMessage(g *protogen.GeneratedFile, message *protogen.Message) error <span class="cov0" title="0">{
        var err error

        data := &amp;messageData{
                message:     message,
                messageName: string(message.Desc.Name()),
                description: utils.FlattenComment(
                        message.Comments.Leading.String() + "\n\n" + message.Comments.Trailing.String(),
                ),
                fields:      map[string]*messageField{},
                fieldsOrder: []string{},
        }

        for _, f := range message.Fields </span><span class="cov0" title="0">{
                field := &amp;messageField{
                        fieldName: string(f.Desc.Name()),
                        description: utils.FlattenComment(
                                f.Comments.Leading.String() + " " + f.Comments.Trailing.String(),
                        ),
                }

                switch f.Desc.Kind() </span>{
                case protoreflect.EnumKind:<span class="cov0" title="0">
                        field.fieldType = "enum"
                        field.fieldMessage = string(f.Enum.Desc.Name())</span>

                case protoreflect.MessageKind:<span class="cov0" title="0">
                        field.fieldType = "message"
                        field.fieldMessage = string(f.Message.Desc.Name())</span>

                default:<span class="cov0" title="0">
                        field.fieldType = f.Desc.Kind().String()</span>
                }

                <span class="cov0" title="0">field.isList = f.Desc.IsList()
                field.options = proto.GetExtension(f.Desc.Options(), validate.E_Field).(*validate.FieldConstraints)

                err = c.processFieldOptions(g, data, field, message)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">data.fields[string(field.fieldName)] = field
                data.fieldsOrder = append(data.fieldsOrder, field.fieldName)</span>
        }

        <span class="cov0" title="0">err = c.writeMessageFieldsTable(g, data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = c.writeMessageFieldValidationTable(g, data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *converter) processFieldOptions(
        f *protogen.GeneratedFile,
        data *messageData,
        row *messageField,
        message *protogen.Message,
) error <span class="cov0" title="0">{
        if row.options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">row.required = row.options.GetRequired()

        return nil</span>
}

func (c *converter) writeMessageFieldsTable(f *protogen.GeneratedFile, messageData *messageData) error <span class="cov8" title="1">{
        f.P("## ", messageData.messageName)
        f.P()

        if messageData.description != "" </span><span class="cov8" title="1">{
                f.P(messageData.description)
                f.P()
        }</span>

        <span class="cov8" title="1">tableData, err := messageData.GetTableData()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tpl := "| %s | %s | %s | %s |"

        f.P(fmt.Sprintf(
                tpl,
                utils.PadRight("Name", " ", tableData.colLengths[0]),
                utils.PadRight("Type", " ", tableData.colLengths[1]),
                utils.PadRight("Required?", " ", tableData.colLengths[2]),
                utils.PadRight("Description", " ", tableData.colLengths[3]),
        ))

        f.P(fmt.Sprintf(
                tpl,
                utils.PadRight("", "-", tableData.colLengths[0]),
                utils.PadRight("", "-", tableData.colLengths[1]),
                utils.PadRight("", "-", tableData.colLengths[2]),
                utils.PadRight("", "-", tableData.colLengths[3]),
        ))

        for _, row := range tableData.rows </span><span class="cov8" title="1">{
                f.P(fmt.Sprintf(
                        tpl,
                        utils.PadRight(row.fieldName, " ", tableData.colLengths[0]),
                        utils.PadRight(row.fieldType, " ", tableData.colLengths[1]),
                        utils.PadRight(utils.BoolToTickOrCross(row.required), " ", tableData.colLengths[2]),
                        utils.PadRight(row.description, " ", tableData.colLengths[3]),
                ))
        }</span>

        <span class="cov8" title="1">f.P()

        return nil</span>
}

func (c *converter) writeMessageFieldValidationTable(f *protogen.GeneratedFile, messageData *messageData) error <span class="cov0" title="0">{
        for _, field := range messageData.fields </span><span class="cov0" title="0">{
                if field.options == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">ignoreEmpty := field.options.GetIgnoreEmpty()

                items := []string{}

                // TODO: There's got to be a better way to do this...
                if s := field.options.GetString_(); s != nil </span><span class="cov0" title="0">{
                        if s.Const != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must be `%s`", *s.Const))
                        }</span>

                        <span class="cov0" title="0">if s.Contains != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must contain `%s`", *s.Contains))
                        }</span>

                        <span class="cov0" title="0">if s.In != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must be one of: `%s`", strings.Join(s.In, "`, `")))
                        }</span>

                        <span class="cov0" title="0">if s.Len != nil </span><span class="cov0" title="0">{
                                msg := "Exactly %d character%s long"
                                if ignoreEmpty </span><span class="cov0" title="0">{
                                        msg = "Must be empty, or exactly %d character%s long"
                                }</span>

                                <span class="cov0" title="0">items = append(items, fmt.Sprintf(msg, *s.Len, utils.PluralSuffix(int(*s.Len), "s", "")))</span>
                        }

                        <span class="cov0" title="0">if s.MinLen != nil </span><span class="cov0" title="0">{
                                msg := "Must be at least %d character%s long"
                                if ignoreEmpty </span><span class="cov0" title="0">{
                                        msg = "Must be empty, or at least %d character%s long"
                                }</span>

                                <span class="cov0" title="0">items = append(items, fmt.Sprintf(msg, *s.MinLen, utils.PluralSuffix(int(*s.MinLen), "s", "")))</span>
                        }

                        <span class="cov0" title="0">if s.MaxLen != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must be %d or fewer character%s long", *s.MaxLen, utils.PluralSuffix(int(*s.MaxLen), "s", "")))
                        }</span>

                        <span class="cov0" title="0">if s.LenBytes != nil </span><span class="cov0" title="0">{
                                msg := "Exactly %d byte%s long"
                                if ignoreEmpty </span><span class="cov0" title="0">{
                                        msg = "Must be empty, or exactly %d byte%s long"
                                }</span>

                                <span class="cov0" title="0">items = append(items, fmt.Sprintf(msg, *s.LenBytes, utils.PluralSuffix(int(*s.LenBytes), "s", "")))</span>
                        }

                        <span class="cov0" title="0">if s.MinBytes != nil </span><span class="cov0" title="0">{
                                msg := "Must be at least %d byte%s long"
                                if ignoreEmpty </span><span class="cov0" title="0">{
                                        msg = "Must be empty, or at least %d byte%s long"
                                }</span>

                                <span class="cov0" title="0">items = append(items, fmt.Sprintf(msg, *s.MinBytes, utils.PluralSuffix(int(*s.MinBytes), "s", "")))</span>
                        }

                        <span class="cov0" title="0">if s.NotContains != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must not contain `%s`", *s.NotContains))
                        }</span>

                        <span class="cov0" title="0">if s.NotIn != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must not be one of: `%s`", strings.Join(s.NotIn, "`, `")))
                        }</span>

                        <span class="cov0" title="0">if s.Pattern != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must match the regex pattern `%s`", *s.Pattern))
                        }</span>

                        <span class="cov0" title="0">if s.Prefix != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must start with `%s`", *s.Prefix))
                        }</span>

                        <span class="cov0" title="0">if s.Suffix != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must end with `%s`", *s.Suffix))
                        }</span>

                        <span class="cov0" title="0">if s.GetAddress() </span><span class="cov0" title="0">{
                                items = append(items, "Must be a valid hostname or IP address")
                        }</span>

                        <span class="cov0" title="0">if s.GetEmail() </span><span class="cov0" title="0">{
                                items = append(items, "Must be a valid email address")
                        }</span>

                        <span class="cov0" title="0">if s.GetHostname() </span><span class="cov0" title="0">{
                                items = append(items, "Must be a valid hostname")
                        }</span>

                        <span class="cov0" title="0">if s.GetIp() </span><span class="cov0" title="0">{
                                items = append(items, "Must be a valid IP address")
                        }</span>

                        <span class="cov0" title="0">if s.GetIpPrefix() </span><span class="cov0" title="0">{
                                items = append(items, "Must be a valid IP prefix (eg, 20.0.0.0/16)")
                        }</span>

                        <span class="cov0" title="0">if s.GetUri() </span><span class="cov0" title="0">{
                                items = append(items, "Must be a valid URI")
                        }</span>

                        <span class="cov0" title="0">if s.GetUriRef() </span><span class="cov0" title="0">{
                                items = append(items, "Must be a valid URI reference")
                        }</span>

                        <span class="cov0" title="0">if s.GetUuid() </span><span class="cov0" title="0">{
                                items = append(items, "Must be a valid UUID")
                        }</span>
                }

                <span class="cov0" title="0">if t := field.options.GetTimestamp(); t != nil </span><span class="cov0" title="0">{
                        if t.Const != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must be `%s`", t.Const.String()))
                        }</span>

                        <span class="cov0" title="0">if t.Within != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must be within %s of now", t.Within.String()))
                        }</span>

                        <span class="cov0" title="0">if t.GetGt() != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must be after %s", t.GetGt().String()))
                        }</span>

                        <span class="cov0" title="0">if t.GetGtNow() </span><span class="cov0" title="0">{
                                items = append(items, "Must be after now")
                        }</span>

                        <span class="cov0" title="0">if t.GetGte() != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must be equal to or after %s", t.GetGte().String()))
                        }</span>

                        <span class="cov0" title="0">if t.GetLt() != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must be before %s", t.GetLt().String()))
                        }</span>

                        <span class="cov0" title="0">if t.GetLtNow() </span><span class="cov0" title="0">{
                                items = append(items, "Must be before now")
                        }</span>

                        <span class="cov0" title="0">if t.GetLte() != nil </span><span class="cov0" title="0">{
                                items = append(items, fmt.Sprintf("Must be equal to or before %s", t.GetLte().String()))
                        }</span>
                }

                <span class="cov0" title="0">if len(items) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">f.P("### `", messageData.messageName, ".", field.fieldName, "` validation")
                f.P()
                f.P("The following validation rules apply to the `", field.fieldName, "` field:")
                f.P()

                for _, item := range items </span><span class="cov0" title="0">{
                        f.P("- ", item)
                }</span>

                <span class="cov0" title="0">f.P()</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package converter

import (
        "fmt"
        "strings"

        "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
        "github.com/omnipeak/protoc-gen-markdown/internal/utils"
        "google.golang.org/protobuf/compiler/protogen"
)

type messageData struct {
        message     *protogen.Message
        messageName string
        description string
        fields      map[string]*messageField
        fieldsOrder []string
}

func (data *messageData) GetTableData() (*messageTableData, error) <span class="cov8" title="1">{
        res := &amp;messageTableData{
                colLengths: []int{4, 4, 9, 11},
                rows:       []*messageTableFieldRow{},
        }

        for _, fieldKey := range data.fieldsOrder </span><span class="cov8" title="1">{
                field, ok := data.fields[fieldKey]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("field %s not found", fieldKey)
                }</span>

                <span class="cov8" title="1">row := &amp;messageTableFieldRow{
                        fieldName:   fmt.Sprintf("`%s`", string(field.fieldName)),
                        description: field.description,
                        required:    field.required,
                }

                switch field.fieldType </span>{
                case "message", "enum":<span class="cov8" title="1">
                        typeName := field.fieldMessage
                        if field.isList </span><span class="cov0" title="0">{
                                typeName += "[]"
                        }</span>

                        <span class="cov8" title="1">row.fieldType = fmt.Sprintf(
                                "[`%s`](#%s)",
                                typeName,
                                strings.ToLower(field.fieldMessage),
                        )</span>

                default:<span class="cov8" title="1">
                        typeName := field.fieldType
                        if field.isList </span><span class="cov8" title="1">{
                                typeName += "[]"
                        }</span>

                        <span class="cov8" title="1">row.fieldType = fmt.Sprintf("`%s`", string(typeName))</span>
                }

                <span class="cov8" title="1">utils.StringGTLengthHelper(&amp;res.colLengths[0], row.fieldName)
                utils.StringGTLengthHelper(&amp;res.colLengths[1], row.fieldType)
                utils.StringGTLengthHelper(&amp;res.colLengths[3], row.description)

                res.rows = append(res.rows, row)</span>
        }

        <span class="cov8" title="1">return res, nil</span>
}

type messageField struct {
        fieldName    string
        fieldType    string
        fieldMessage string
        isList       bool
        required     bool
        description  string
        options      *validate.FieldConstraints
}

type messageTableData struct {
        colLengths []int
        rows       []*messageTableFieldRow
}

type messageTableFieldRow struct {
        fieldName   string
        fieldType   string
        required    bool
        description string
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package converter

import (
        "fmt"

        "github.com/omnipeak/protoc-gen-markdown/internal/utils"
        "google.golang.org/protobuf/compiler/protogen"
)

func (c *converter) processService(g *protogen.GeneratedFile, svc *protogen.Service) error <span class="cov0" title="0">{
        data := &amp;serviceData{
                svc:          svc,
                serviceName:  string(svc.Desc.Name()),
                description:  utils.FlattenComment(svc.Comments.Leading.String() + "\n\n" + svc.Comments.Trailing.String()),
                methods:      make(map[string]*serviceMethodData),
                methodsOrder: []string{},
        }

        for _, m := range svc.Methods </span><span class="cov0" title="0">{
                method := &amp;serviceMethodData{
                        methodName:  string(m.Desc.Name()),
                        params:      []string{},
                        description: utils.FlattenComment(m.Comments.Leading.String() + "\n\n" + m.Comments.Trailing.String()),
                }

                method.params = append(method.params, string(m.Input.Desc.Name()))
                method.response = string(m.Output.Desc.Name())

                data.methods[method.methodName] = method
                data.methodsOrder = append(data.methodsOrder, method.methodName)
        }</span>

        <span class="cov0" title="0">c.writeServiceFieldsTable(g, data)

        return nil</span>
}

func (c *converter) writeServiceFieldsTable(g *protogen.GeneratedFile, data *serviceData) error <span class="cov8" title="1">{
        g.P("## ", data.serviceName)
        g.P()

        if data.description != "" </span><span class="cov8" title="1">{
                g.P(data.description)
                g.P()
        }</span>

        <span class="cov8" title="1">g.P("### Methods")
        g.P()

        tableData, err := data.GetTableData()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tpl := "| %s | %s | %s | %s |"

        g.P(fmt.Sprintf(
                tpl,
                utils.PadRight("Method", " ", tableData.colLengths[0]),
                utils.PadRight("Inputs", " ", tableData.colLengths[1]),
                utils.PadRight("Response", " ", tableData.colLengths[2]),
                utils.PadRight("Description", " ", tableData.colLengths[3]),
        ))

        g.P(fmt.Sprintf(
                tpl,
                utils.PadRight("", "-", tableData.colLengths[0]),
                utils.PadRight("", "-", tableData.colLengths[1]),
                utils.PadRight("", "-", tableData.colLengths[2]),
                utils.PadRight("", "-", tableData.colLengths[3]),
        ))

        for _, row := range tableData.rows </span><span class="cov8" title="1">{
                g.P(fmt.Sprintf(
                        tpl,
                        utils.PadRight(row.methodName, " ", tableData.colLengths[0]),
                        utils.PadRight(row.inputs, " ", tableData.colLengths[1]),
                        utils.PadRight(row.response, " ", tableData.colLengths[2]),
                        utils.PadRight(row.description, " ", tableData.colLengths[3]),
                ))
        }</span>

        <span class="cov8" title="1">g.P()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package converter

import (
        "fmt"
        "strings"

        "github.com/omnipeak/protoc-gen-markdown/internal/utils"
        "google.golang.org/protobuf/compiler/protogen"
)

type serviceData struct {
        svc          *protogen.Service
        serviceName  string
        description  string
        methods      map[string]*serviceMethodData
        methodsOrder []string
}

func (sd *serviceData) GetTableData() (*serviceTableData, error) <span class="cov8" title="1">{
        data := &amp;serviceTableData{
                colLengths: []int{9, 40, 25, 35},
                rows:       []*serviceTableMethodRow{},
        }

        for _, methodName := range sd.methodsOrder </span><span class="cov8" title="1">{
                method, ok := sd.methods[methodName]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("method %s not found", methodName)
                }</span>

                <span class="cov8" title="1">row := &amp;serviceTableMethodRow{
                        methodName:  fmt.Sprintf("`%s`", method.methodName),
                        description: method.description,
                }

                inputBits := []string{}
                for _, p := range method.params </span><span class="cov8" title="1">{
                        inputBits = append(inputBits, fmt.Sprintf("[`%s`](#%s)", p, strings.ToLower(p)))
                }</span>

                <span class="cov8" title="1">row.inputs = strings.Join(inputBits, ", ")
                row.response = fmt.Sprintf("[`%s`](#%s)", method.response, strings.ToLower(method.response))

                utils.StringGTLengthHelper(&amp;data.colLengths[0], row.methodName)
                utils.StringGTLengthHelper(&amp;data.colLengths[1], row.inputs)
                utils.StringGTLengthHelper(&amp;data.colLengths[2], row.response)
                utils.StringGTLengthHelper(&amp;data.colLengths[3], row.description)

                data.rows = append(data.rows, row)</span>
        }

        <span class="cov8" title="1">return data, nil</span>
}

type serviceMethodData struct {
        methodName  string
        params      []string
        response    string
        description string
}

type serviceTableData struct {
        colLengths []int
        rows       []*serviceTableMethodRow
}

type serviceTableMethodRow struct {
        methodName  string
        inputs      string
        response    string
        description string
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package utils

import (
        "regexp"
        "strings"
        "unicode/utf8"
)

func StringGTLengthHelper(v *int, s string) <span class="cov8" title="1">{
        if utf8.RuneCountInString(s) &gt; *v </span><span class="cov8" title="1">{
                *v = utf8.RuneCountInString(s)
        }</span>
}

func PadRight(s string, padWith string, wantedLength int) string <span class="cov8" title="1">{
        output := s

        if padWith == "" </span><span class="cov8" title="1">{
                padWith = " "
        }</span>

        <span class="cov8" title="1">if utf8.RuneCountInString(s) &gt; wantedLength </span><span class="cov8" title="1">{
                output = s[:wantedLength]
        }</span>

        <span class="cov8" title="1">if utf8.RuneCountInString(output) &lt; wantedLength </span><span class="cov8" title="1">{
                output += strings.Repeat(padWith, wantedLength-utf8.RuneCountInString(output))
        }</span>

        <span class="cov8" title="1">return output</span>
}

func BoolToTickOrCross(b bool) string <span class="cov8" title="1">{
        if b </span><span class="cov8" title="1">{
                return "✅"
        }</span>

        <span class="cov8" title="1">return "❌"</span>
}

var commentStripRegex = regexp.MustCompile(`(?m)^\s*//\s*`)
var newlineRegex = regexp.MustCompile(`(?m)\s*\n\s*`)

func FlattenComment(s string) string <span class="cov8" title="1">{
        return strings.Trim(
                newlineRegex.ReplaceAllString(
                        commentStripRegex.ReplaceAllString(s, " "),
                        " ",
                ),
                " \t\r\n",
        )
}</span>

func PluralSuffix(check int, pluralSuffix string, singularSuffix string) string <span class="cov8" title="1">{
        if check == 1 </span><span class="cov8" title="1">{
                return singularSuffix
        }</span>

        <span class="cov8" title="1">return pluralSuffix</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package main is the entry point for the plugin
package main

import (
        "github.com/omnipeak/protoc-gen-markdown/internal/converter"
)

func main() <span class="cov0" title="0">{
        converter.Run()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
